<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Color Palette Generator</title>
    <link rel="icon"
        href="data:image/png;base64,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"
        type="image/x-icon">

    <style>
        /* Default (Dark Mode) */
        html {
            background: #282828;
            transition: background-color 0.3s ease;
            /* Add transition */
        }

        body {
            align-items: center;
            background: #282828;
            box-sizing: border-box;
            color: #cccccc;
            display: flex;
            flex-direction: column;
            font-family: 'Source Code Pro', monospace;
            font-size: 18px;
            margin: 0;
            min-height: 100vh;
            padding: 20px;
            transition: background-color 0.3s ease, color 0.3s ease;
            /* Add transition */
        }

        /* Light Mode Styles */
        html.light-mode {
            background: #e3e3e3;
        }

        body.light-mode {
            background-color: #e3e3e3;
            color: #2e2e2e;
        }

        /* Optional: Adjust control backgrounds for light mode */
        body.light-mode .controls,
        body.light-mode .export-controls {
            background-color: #d0d0d0;
        }

        body.light-mode .control-group label {
            color: #333;
            /* Darker labels */
        }

        body.light-mode .controls input[type="number"] {
            background-color: #f0f0f0;
            border-color: #aaa;
            color: #222;
        }

        body.light-mode button {
            background-color: #bbb;
            color: #222;
        }

        body.light-mode button:hover {
            background-color: #a5a5a5;
        }

        body.light-mode .controls button:hover,
        body.light-mode .export-controls button:hover {
            background-color: #529dcf;
            /* Keep hover blue for contrast */
            color: white;
        }

        h1 {
            margin-bottom: 20px;
            margin-top: 0;
            text-align: center;
        }

        .theme-toggle-container {
            margin-bottom: 20px;
        }

        #toggle-theme-button {
            padding: 8px 15px;
            font-size: 0.9em;
            cursor: pointer;
            border-radius: 4px;
            border: none;
            /* Default dark mode style */
            background-color: #666;
            color: white;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        #toggle-theme-button:hover {
            background-color: #529dcf;
        }


        .controls {
            align-items: flex-end;
            background-color: #3a3a3a;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
            padding: 15px;
            transition: background-color 0.3s ease;
            /* Add transition */
        }

        .export-controls {
            align-items: center;
            background-color: #3a3a3a;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
            margin-top: 0;
            padding: 15px;
            transition: background-color 0.3s ease;
            /* Add transition */
        }


        .control-group {
            border: 1px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            padding: 8px;
        }

        .control-group label {
            color: #ccc;
            font-size: 0.8em;
            margin-bottom: 5px;
            transition: color 0.3s ease;
            /* Add transition */
        }

        .controls input[type="number"] {
            appearance: textfield;
            background-color: #444;
            border: 1px solid #555;
            border-radius: 4px;
            color: #ccc;
            padding: 8px;
            width: 60px;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            /* Add transition */
        }

        /* Hide spinner buttons for number inputs (optional aesthetic) */
        .controls input[type=number]::-webkit-inner-spin-button,
        .controls input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .controls input[type=number] {
            appearance: textfield;
        }

        .controls .radio-group,
        .export-controls .radio-group {
            align-items: center;
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }

        .controls .radio-group input[type="radio"],
        .export-controls .radio-group input[type="radio"] {
            margin-right: 3px;
            margin-top: 0;
        }

        .controls button,
        .export-controls button {
            background-color: #666;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: .9em;
            padding: 8px 15px;
            transition: background-color 0.2s ease, color 0.2s ease;
            /* Add transition */
        }

        .controls button:hover,
        .export-controls button:hover {
            background-color: #529dcf;
        }

        #palette-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 50px 0 70px;
        }

        .colour-item {
            align-items: center;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .colour-input {
            border: 1px solid #555;
            border-radius: 8px;
            box-sizing: border-box;
            height: 80px;
            width: 120px;
            display: block;
            transition: border-color 0.3s ease;
            /* Add transition */
        }

        /* Optional: Adjust swatch border in light mode */
        body.light-mode .colour-input {
            border-color: #bbb;
        }


        .colour-code {
            font-size: 0.9em;
            max-width: 90px;
            text-align: center;
            word-break: break-all;
            /* Color is set dynamically by JS, no need for transition here */
        }
    </style>
</head>

<body>

    <h1>Dynamic Color Palette Generator</h1>

    <div class="theme-toggle-container">
        <button id="toggle-theme-button">Toggle Light / Dark</button>
    </div>

    <div style="display: flex; justify-content: center; margin-bottom: 20px;">
        <div id="colorPickerContainer"></div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="base-hue">Hue (°)</label>
            <input type="number" id="base-hue" value="0" min="0" max="359">
        </div>
        <div class="control-group">
            <label for="base-saturation">Saturation (%)</label>
            <input type="number" id="base-saturation" value="60" min="0" max="100">
        </div>
        <div class="control-group">
            <label for="base-lightness">Lightness (%)</label>
            <input type="number" id="base-lightness" value="75" min="0" max="100">
        </div>
        <div class="control-group">
            <label for="increment-value">Increment by:</label>
            <input type="number" id="increment-value" value="24" min="1" max="360">
        </div>
        <div class="control-group">
            <label>Vary component:</label>
            <div class="radio-group">
                <input type="radio" id="vary-hue" name="vary-param" value="hue" checked>
                <label for="vary-hue">Hue</label>

                <input type="radio" id="vary-saturation" name="vary-param" value="saturation">
                <label for="vary-saturation">Saturation</label>

                <input type="radio" id="vary-lightness" name="vary-param" value="lightness">
                <label for="vary-lightness">Lightness</label>
            </div>
        </div>
        <button id="generate-button">Generate Palette</button>
    </div>

    <div id="palette-container">
    </div>

    <div class="export-controls">
        <div class="control-group">
            <label>Export Format</label>
            <div class="radio-group">
                <input type="radio" id="format-hex" name="export-format" value="hex" checked>
                <label for="format-hex">Hex</label>

                <input type="radio" id="format-hsl" name="export-format" value="hsl">
                <label for="format-hsl">HSL</label>

                <input type="radio" id="format-rgb" name="export-format" value="rgb">
                <label for="format-rgb">RGB</label>
            </div>
        </div>
        <button id="export-button">Export to CSS</button>
        <button id="export-xml-button">Export to XML</button>
    </div>

    <script>
        // Variable to store the generated palette data (HSL values)
        let generatedColors = [];

        // Function to convert HSL to Hexadecimal color code
        // H: Hue (0-360), S: Saturation (0-100), L: Lightness (0-100)
        function hslToHex(h, s, l) {
            // Ensure h is within [0, 360)
            h = h % 360;
            if (h < 0) {
                h += 360;
            }

            // Convert s and l to be within [0, 1]
            s /= 100;
            l /= 100;

            let c = (1 - Math.abs(2 * l - 1)) * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = l - c / 2;
            let r = 0;
            let g = 0;
            let b = 0;

            if (0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if (300 <= h && h < 360) {
                r = c; g = 0; b = x;
            }

            // Convert RGB [0, 1] to [0, 255] and round
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);

            // Convert RGB to Hex string
            const toHex = (c) => {
                const hex = c.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            };

            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        // Function to convert HSL to RGB object (0-255)
        // H: Hue (0-360), S: Saturation (0-100), L: Lightness (0-100)
        function hslToRgb(h, s, l) {
            // Ensure h is within [0, 360)
            h = h % 360;
            if (h < 0) {
                h += 360;
            }

            // Convert s and l to be within [0, 1]
            s /= 100;
            l /= 100;

            let c = (1 - Math.abs(2 * l - 1)) * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = l - c / 2;
            let r = 0;
            let g = 0;
            let b = 0;

            if (0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if (300 <= h && h < 360) {
                r = c; g = 0; b = x;
            }

            // Convert RGB [0, 1] to [0, 255] and round
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);

            return { r: r, g: g, b: b };
        }


        // Helper function to create and append a single swatch item
        function createSwatch(h, s, l, hexColor, container) {
            // Create the container div for a single colour item (swatch + hex code)
            const colourItem = document.createElement('div');
            colourItem.classList.add('colour-item');

            // Create a div element instead of an input[type=color]
            const colourSwatchDiv = document.createElement('div');
            colourSwatchDiv.classList.add('colour-input');
            colourSwatchDiv.style.backgroundColor = hexColor;
            // Add a title attribute for a tooltip with HSL and Hex values
            colourSwatchDiv.title = `HSL(${h} ${s}% ${l}%) - ${hexColor}`;

            // Create the div to display the hex code text
            const colourCode = document.createElement('div');
            colourCode.classList.add('colour-code');
            colourCode.textContent = hexColor;
            colourCode.style.color = hexColor; // Display text in its own color

            colourItem.appendChild(colourSwatchDiv);
            colourItem.appendChild(colourCode);

            container.appendChild(colourItem);
        }


        // Function to generate and display the colour palette based on inputs
        function generatePalette() {
            // Get input elements
            const baseHueInput = document.getElementById('base-hue');
            const baseSaturationInput = document.getElementById('base-saturation');
            const baseLightnessInput = document.getElementById('base-lightness');
            const incrementValueInput = document.getElementById('increment-value');
            const varyParamRadios = document.querySelectorAll('input[name="vary-param"]');
            const paletteContainer = document.getElementById('palette-container');

            // Get current values from inputs
            const baseH = parseInt(baseHueInput.value);
            const baseS = parseInt(baseSaturationInput.value);
            const baseL = parseInt(baseLightnessInput.value);
            const increment = parseInt(incrementValueInput.value);

            let varyParam = 'hue'; // Default to varying Hue
            for (const radio of varyParamRadios) {
                if (radio.checked) {
                    varyParam = radio.value;
                    break;
                }
            }

            // Basic validation of input values
            if (isNaN(baseH) || baseH < 0 || baseH > 359) {
                alert('Please enter a valid Base Hue (0-359).');
                baseHueInput.focus();
                return;
            }
            if (isNaN(baseS) || baseS < 0 || baseS > 100) {
                alert('Please enter a valid Base Saturation (0-100).');
                baseSaturationInput.focus();
                return;
            }
            if (isNaN(baseL) || baseL < 0 || baseL > 100) {
                alert('Please enter a valid Base Lightness (0-100).');
                baseLightnessInput.focus();
                return;
            }
            // Max increment depends on the varying parameter, but 360 is a safe upper bound for the input field
            if (isNaN(increment) || increment < 1) {
                alert('Please enter a valid Increment Value (1 or greater).');
                incrementValueInput.focus();
                return;
            }
            // Although the input max is 360, for Saturation/Lightness, it doesn't make sense to increment by more than 100
            if ((varyParam === 'saturation' || varyParam === 'lightness') && increment > 100) {
                alert('Saturation or Lightness Increment cannot exceed 100.');
                incrementValueInput.focus();
                return;
            }

            // Clear any previously generated palette items and stored data
            paletteContainer.innerHTML = '';
            generatedColors = []; // Clear the stored palette data

            // Generate colours based on the selected varying parameter
            let palette = [];
            if (varyParam === 'hue') {
                // Calculate increments up and down from baseH, ensuring uniqueness and wrapping
                let hues = new Set();
                hues.add(baseH);
                let maxColors = Math.ceil(360 / increment); // Estimate max colors needed
                let currentH = baseH;
                for (let i = 1; hues.size < maxColors + 1 && i <= maxColors; i++) { // Add safety break
                    currentH = (baseH + i * increment + 360) % 360;
                    if (hues.has(currentH)) break; // Stop if we loop completely
                    hues.add(currentH);
                }
                currentH = baseH;
                for (let i = 1; hues.size < maxColors + 1 && i <= maxColors; i++) { // Add safety break
                    currentH = (baseH - i * increment + 360) % 360;
                    if (hues.has(currentH)) break; // Stop if we loop completely
                    hues.add(currentH);
                }

                palette = Array.from(hues).map(h => ({ h: Math.round(h), s: baseS, l: baseL }));
                palette.sort((a, b) => a.h - b.h);

            } else if (varyParam === 'saturation') {
                let sats = new Set();
                sats.add(baseS);
                for (let s = baseS + increment; s <= 100; s += increment) {
                    sats.add(s);
                }
                for (let s = baseS - increment; s >= 0; s -= increment) {
                    sats.add(s);
                }
                palette = Array.from(sats).map(s => ({ h: baseH, s, l: baseL }));
                palette.sort((a, b) => a.s - b.s);
            } else if (varyParam === 'lightness') {
                let lights = new Set();
                lights.add(baseL);
                for (let l = baseL + increment; l <= 100; l += increment) {
                    lights.add(l);
                }
                for (let l = baseL - increment; l >= 0; l -= increment) {
                    lights.add(l);
                }
                palette = Array.from(lights).map(l => ({ h: baseH, s: baseS, l }));
                palette.sort((a, b) => a.l - b.l);
            }
            // Store and display
            generatedColors = palette;
            for (const color of palette) {
                const hexColor = hslToHex(color.h, color.s, color.l);
                createSwatch(color.h, color.s, color.l, hexColor, paletteContainer);
            }
        }

        // Function to export the generated palette as a CSS file
        function exportCssPalette() {
            // Check if a palette has been generated
            if (generatedColors.length === 0) {
                alert("Generate a palette first!");
                return;
            }

            // Get current input values to include in the comment
            const baseHueInput = document.getElementById('base-hue');
            const baseSaturationInput = document.getElementById('base-saturation');
            const baseLightnessInput = document.getElementById('base-lightness');
            const incrementValueInput = document.getElementById('increment-value');
            const varyParamRadios = document.querySelectorAll('input[name="vary-param"]');
            const exportFormatRadios = document.querySelectorAll('input[name="export-format"]');

            const baseH = parseInt(baseHueInput.value);
            const baseS = parseInt(baseSaturationInput.value);
            const baseL = parseInt(baseLightnessInput.value);
            const increment = parseInt(incrementValueInput.value);

            let varyParam = 'hue';
            for (const radio of varyParamRadios) {
                if (radio.checked) {
                    varyParam = radio.value;
                    break;
                }
            }

            let exportFormat = 'hex';
            for (const radio of exportFormatRadios) {
                if (radio.checked) {
                    exportFormat = radio.value;
                    break;
                }
            }

            // Construct the comment string describing the palette
            let varyingParameter = varyParam.charAt(0).toUpperCase() + varyParam.slice(1); // Capitalise first letter
            let unit = '';
            if (varyParam === 'hue') {
                unit = '°';
            } else if (varyParam === 'saturation' || varyParam === 'lightness') {
                unit = '%';
            }

            const comment = `/*\n * Palette of colors based on HSL(${baseH} ${baseS}% ${baseL}%)\n * Varying on ${varyingParameter}, in increments of ${increment}${unit}\n * Exported as ${exportFormat.toUpperCase()}\n */\n\n`;


            let cssContent = comment + ':root {\n'; // Prepend comment and start the :root block in CSS

            // Iterate through the stored colour data
            generatedColors.forEach((color, index) => {
                // Format the CSS variable name --color-NNN, padded with leading zeros
                const varName = `--color-${String(index + 1).padStart(3, '0')}`;

                let colorValueString = '';
                if (exportFormat === 'hex') {
                    // Convert HSL to Hex for export
                    colorValueString = hslToHex(color.h, color.s, color.l);
                } else if (exportFormat === 'hsl') {
                    // Use stored HSL format
                    colorValueString = `hsl(${color.h} ${color.s}% ${color.l}%)`;
                } else if (exportFormat === 'rgb') {
                    // Convert HSL to RGB and format as rgb(r, g, b)
                    const rgb = hslToRgb(color.h, color.s, color.l);
                    colorValueString = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                }

                // Add the variable definition to the CSS content string with indentation
                cssContent += `  ${varName}: ${colorValueString};\n`;
            });

            cssContent += '}'; // Close the :root block

            // Create a Blob containing the CSS string
            const blob = new Blob([cssContent], { type: 'text/css' });

            // Create a temporary anchor element for the download
            const a = document.createElement('a');

            // Create a URL for the blob using the browser's createObjectURL method
            a.href = URL.createObjectURL(blob);

            // Set the download attribute with the desired filename in 'Palette yymmddHHMM.css' format
            const now = new Date();
            const pad = n => n.toString().padStart(2, '0');
            const y = now.getFullYear().toString().slice(-2);
            const m = pad(now.getMonth() + 1);
            const d = pad(now.getDate());
            const H = pad(now.getHours());
            const M = pad(now.getMinutes());
            a.download = `Palette ${y}${m}${d}${H}${M}.css`;

            // Append the link to the body (required for some browsers like Firefox to trigger click)
            document.body.appendChild(a);

            // Programmatically click the link to trigger the download
            a.click();

            // Clean up: remove the temporary link element from the DOM
            // and revoke the object URL to free up memory.
            // Use a short timeout to ensure the download action is initiated before cleanup.
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }, 100); // 100ms delay for cleanup

        }

        // Function to export the generated palette as an XML file
        function exportXmlPalette() {
            if (generatedColors.length === 0) {
                alert("Generate a palette first!");
                return;
            }
            const baseHueInput = document.getElementById('base-hue');
            const baseSaturationInput = document.getElementById('base-saturation');
            const baseLightnessInput = document.getElementById('base-lightness');
            const incrementValueInput = document.getElementById('increment-value');
            const varyParamRadios = document.querySelectorAll('input[name="vary-param"]');
            const exportFormatRadios = document.querySelectorAll('input[name="export-format"]');

            const baseH = parseInt(baseHueInput.value);
            const baseS = parseInt(baseSaturationInput.value);
            const baseL = parseInt(baseLightnessInput.value);
            const increment = parseInt(incrementValueInput.value);

            let varyParam = 'hue';
            for (const radio of varyParamRadios) {
                if (radio.checked) {
                    varyParam = radio.value;
                    break;
                }
            }
            let exportFormat = 'hex';
            for (const radio of exportFormatRadios) {
                if (radio.checked) {
                    exportFormat = radio.value;
                    break;
                }
            }
            let varyingParameter = varyParam.charAt(0).toUpperCase() + varyParam.slice(1);
            let unit = '';
            if (varyParam === 'hue') {
                unit = '°';
            } else if (varyParam === 'saturation' || varyParam === 'lightness') {
                unit = '%';
            }
            let xmlContent = `<?xml version="1.0" encoding="UTF-8"?>\n<!--\n    Palette of colors based on HSL(${baseH} ${baseS}% ${baseL}%)\n    Varying on ${varyingParameter}, in increments of ${increment}${unit}\n    Exported as ${exportFormat.toUpperCase()}\n-->\n<Palette>\n\n`;
            generatedColors.forEach((color, index) => {
                let valueAttr = '';
                let attrName = '';
                if (exportFormat === 'hex') {
                    valueAttr = hslToHex(color.h, color.s, color.l);
                    attrName = 'hexvalue';
                } else if (exportFormat === 'hsl') {
                    valueAttr = `hsl(${color.h} ${color.s}% ${color.l}%)`;
                    attrName = 'hslvalue';
                } else if (exportFormat === 'rgb') {
                    const rgb = hslToRgb(color.h, color.s, color.l);
                    valueAttr = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                    attrName = 'rgbvalue';
                }
                let name = `color${String(index + 1).padStart(3, '0')}`; // Padded name
                xmlContent += `    <myColor ${attrName}="${valueAttr}" name="${name}" />\n`;
            });
            xmlContent += "\n</Palette>";
            const blob = new Blob([xmlContent], { type: 'application/xml' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            const now = new Date();
            const pad = n => n.toString().padStart(2, '0');
            const y = now.getFullYear().toString().slice(-2);
            const m = pad(now.getMonth() + 1);
            const d = pad(now.getDate());
            const H = pad(now.getHours());
            const M = pad(now.getMinutes());
            a.download = `palette ${y}${m}${d}${H}${M}.xml`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }, 100);
        }

        // Initialize iro.js color picker
        let colorPicker;
        document.addEventListener('DOMContentLoaded', () => {
            // Get references to the buttons after the DOM is fully loaded
            const generateButton = document.getElementById('generate-button');
            const exportButton = document.getElementById('export-button');
            const exportXmlButton = document.getElementById('export-xml-button');
            const themeToggleButton = document.getElementById('toggle-theme-button'); // Get theme toggle button

            // Add event listeners to the buttons
            generateButton.addEventListener('click', generatePalette);
            exportButton.addEventListener('click', exportCssPalette);
            exportXmlButton.addEventListener('click', exportXmlPalette);

            // Add Theme Toggle Listener
            const htmlElement = document.documentElement;
            const bodyElement = document.body;
            themeToggleButton.addEventListener('click', () => {
                htmlElement.classList.toggle('light-mode');
                bodyElement.classList.toggle('light-mode');
                // Optional: Adjust color picker theme if possible / needed
                // (Requires checking iro.js docs if it supports theme changes)
            });


            // Initialize iro.js color picker
            // Make sure the iro.js script is loaded before this runs
            if (typeof iro !== 'undefined') {
                colorPicker = new iro.ColorPicker('#colorPickerContainer', {
                    width: 220,
                    color: { h: 0, s: 60, l: 75 }, // Initial HSL
                    layout: 'default',
                    // Optional: Try setting a border color that works in both modes
                    // borderColor: '#888'
                });

                // Update HSL inputs when color picker changes
                colorPicker.on('color:change', function (color) {
                    document.getElementById('base-hue').value = Math.round(color.hsl.h);
                    document.getElementById('base-saturation').value = Math.round(color.hsl.s);
                    document.getElementById('base-lightness').value = Math.round(color.hsl.l);
                });

                // Sync color picker when HSL inputs change
                const hInput = document.getElementById('base-hue');
                const sInput = document.getElementById('base-saturation');
                const lInput = document.getElementById('base-lightness');
                function updateColorPickerFromInputs() {
                    const h = parseInt(hInput.value);
                    const s = parseInt(sInput.value);
                    const l = parseInt(lInput.value);
                    // Check if inputs are valid numbers before updating the picker
                    if (colorPicker && !isNaN(h) && !isNaN(s) && !isNaN(l) && h >= 0 && h <= 359 && s >= 0 && s <= 100 && l >= 0 && l <= 100) {
                        // Suppress the 'color:change' event temporarily while setting programmatically
                        // to avoid potential feedback loops if not handled carefully
                        // colorPicker.off('color:change'); // Not standard iro.js API for temporary off
                        colorPicker.color.hsl = { h, s, l };
                        // colorPicker.on('color:change', ...); // Re-attach if needed
                    }
                }
                hInput.addEventListener('input', updateColorPickerFromInputs);
                sInput.addEventListener('input', updateColorPickerFromInputs);
                lInput.addEventListener('input', updateColorPickerFromInputs);

                // Initial generation after setup
                generatePalette();
            } else {
                console.error("iro.js library not loaded.");
                // Optionally display an error message to the user
                document.getElementById('colorPickerContainer').textContent = "Error: Color Picker library failed to load.";
                // Still call generatePalette to show swatches even without picker
                generatePalette();
            }

        });

    </script>

    <!-- Color Picker Library (Bundled inline) -->
    <script>
        /*!
        * iro.js v5.5.2
        * 2016-2021 James Daniel
        * Licensed under MPL 2.0
        * github.com/jaames/iro.js
        */
        !function (t, n) { "object" == typeof exports && "undefined" != typeof module ? module.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = t || self).iro = n() }(this, function () { "use strict"; var m, s, n, i, o, x = {}, j = [], r = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i; function M(t, n) { for (var i in n) t[i] = n[i]; return t } function y(t) { var n = t.parentNode; n && n.removeChild(t) } function h(t, n, i) { var r, e, u, o, l = arguments; if (n = M({}, n), 3 < arguments.length) for (i = [i], r = 3; r < arguments.length; r++)i.push(l[r]); if (null != i && (n.children = i), null != t && null != t.defaultProps) for (e in t.defaultProps) void 0 === n[e] && (n[e] = t.defaultProps[e]); return o = n.key, null != (u = n.ref) && delete n.ref, null != o && delete n.key, c(t, n, o, u) } function c(t, n, i, r) { var e = { type: t, props: n, key: i, ref: r, n: null, i: null, e: 0, o: null, l: null, c: null, constructor: void 0 }; return m.vnode && m.vnode(e), e } function O(t) { return t.children } function I(t, n) { this.props = t, this.context = n } function w(t, n) { if (null == n) return t.i ? w(t.i, t.i.n.indexOf(t) + 1) : null; for (var i; n < t.n.length; n++)if (null != (i = t.n[n]) && null != i.o) return i.o; return "function" == typeof t.type ? w(t) : null } function a(t) { var n, i; if (null != (t = t.i) && null != t.c) { for (t.o = t.c.base = null, n = 0; n < t.n.length; n++)if (null != (i = t.n[n]) && null != i.o) { t.o = t.c.base = i.o; break } return a(t) } } function e(t) { (!t.f && (t.f = !0) && 1 === s.push(t) || i !== m.debounceRendering) && (i = m.debounceRendering, (m.debounceRendering || n)(u)) } function u() { var t, n, i, r, e, u, o, l; for (s.sort(function (t, n) { return n.d.e - t.d.e }); t = s.pop();)t.f && (r = i = void 0, u = (e = (n = t).d).o, o = n.p, l = n.u, n.u = !1, o && (i = [], r = k(o, e, M({}, e), n.w, void 0 !== o.ownerSVGElement, null, i, l, null == u ? w(e) : u), d(i, e), r != u && a(e))) } function S(n, i, t, r, e, u, o, l, s) { var c, a, f, h, v, d, g, b = t && t.n || j, p = b.length; if (l == x && (l = null != u ? u[0] : p ? w(t, 0) : null), c = 0, i.n = A(i.n, function (t) { if (null != t) { if (t.i = i, t.e = i.e + 1, null === (f = b[c]) || f && t.key == f.key && t.type === f.type) b[c] = void 0; else for (a = 0; a < p; a++) { if ((f = b[a]) && t.key == f.key && t.type === f.type) { b[a] = void 0; break } f = null } if (h = k(n, t, f = f || x, r, e, u, o, null, l, s), (a = t.ref) && f.ref != a && (g = g || []).push(a, t.c || h, t), null != h) { if (null == d && (d = h), null != t.l) h = t.l, t.l = null; else if (u == f || h != l || null == h.parentNode) { t: if (null == l || l.parentNode !== n) n.appendChild(h); else { for (v = l, a = 0; (v = v.nextSibling) && a < p; a += 2)if (v == h) break t; n.insertBefore(h, l) } "option" == i.type && (n.value = "") } l = h.nextSibling, "function" == typeof i.type && (i.l = h) } } return c++, t }), i.o = d, null != u && "function" != typeof i.type) for (c = u.length; c--;)null != u[c] && y(u[c]); for (c = p; c--;)null != b[c] && N(b[c], b[c]); if (g) for (c = 0; c < g.length; c++)E(g[c], g[++c], g[++c]) } function A(t, n, i) { if (null == i && (i = []), null == t || "boolean" == typeof t) n && i.push(n(null)); else if (Array.isArray(t)) for (var r = 0; r < t.length; r++)A(t[r], n, i); else i.push(n ? n(function (t) { if (null == t || "boolean" == typeof t) return null; if ("string" == typeof t || "number" == typeof t) return c(null, t, null, null); if (null == t.o && null == t.c) return t; var n = c(t.type, t.props, t.key, null); return n.o = t.o, n }(t)) : t); return i } function f(t, n, i) { "-" === n[0] ? t.setProperty(n, i) : t[n] = "number" == typeof i && !1 === r.test(n) ? i + "px" : null == i ? "" : i } function R(t, n, i, r, e) { var u, o, l, s, c; if ("key" === (n = e ? "className" === n ? "class" : n : "class" === n ? "className" : n) || "children" === n); else if ("style" === n) if (u = t.style, "string" == typeof i) u.cssText = i; else { if ("string" == typeof r && (u.cssText = "", r = null), r) for (o in r) i && o in i || f(u, o, ""); if (i) for (l in i) r && i[l] === r[l] || f(u, l, i[l]) } else "o" === n[0] && "n" === n[1] ? (s = n !== (n = n.replace(/Capture$/, "")), n = ((c = n.toLowerCase()) in t ? c : n).slice(2), i ? (r || t.addEventListener(n, v, s), (t.t || (t.t = {}))[n] = i) : t.removeEventListener(n, v, s)) : "list" !== n && "tagName" !== n && "form" !== n && !e && n in t ? t[n] = null == i ? "" : i : "function" != typeof i && "dangerouslySetInnerHTML" !== n && (n !== (n = n.replace(/^xlink:?/, "")) ? null == i || !1 === i ? t.removeAttributeNS("http://www.w3.org/1999/xlink", n.toLowerCase()) : t.setAttributeNS("http://www.w3.org/1999/xlink", n.toLowerCase(), i) : null == i || !1 === i ? t.removeAttribute(n) : t.setAttribute(n, i)) } function v(t) { return this.t[t.type](m.event ? m.event(t) : t) } function k(t, n, i, r, e, u, o, l, s, c) { var a, f, h, v, d, g, b, p, y, w, k = n.type; if (void 0 !== n.constructor) return null; (a = m.e) && a(n); try { t: if ("function" == typeof k) { if (p = n.props, y = (a = k.contextType) && r[a.c], w = a ? y ? y.props.value : a.i : r, i.c ? b = (f = n.c = i.c).i = f.k : ("prototype" in k && k.prototype.render ? n.c = f = new k(p, w) : (n.c = f = new I(p, w), f.constructor = k, f.render = z), y && y.sub(f), f.props = p, f.state || (f.state = {}), f.context = w, f.w = r, h = f.f = !0, f.m = []), null == f.j && (f.j = f.state), null != k.getDerivedStateFromProps && M(f.j == f.state ? f.j = M({}, f.j) : f.j, k.getDerivedStateFromProps(p, f.j)), h) null == k.getDerivedStateFromProps && null != f.componentWillMount && f.componentWillMount(), null != f.componentDidMount && o.push(f); else { if (null == k.getDerivedStateFromProps && null == l && null != f.componentWillReceiveProps && f.componentWillReceiveProps(p, w), !l && null != f.shouldComponentUpdate && !1 === f.shouldComponentUpdate(p, f.j, w)) { for (f.props = p, f.state = f.j, f.f = !1, (f.d = n).o = null != s ? s !== i.o ? s : i.o : null, n.n = i.n, a = 0; a < n.n.length; a++)n.n[a] && (n.n[a].i = n); break t } null != f.componentWillUpdate && f.componentWillUpdate(p, f.j, w) } for (v = f.props, d = f.state, f.context = w, f.props = p, f.state = f.j, (a = m.M) && a(n), f.f = !1, f.d = n, f.p = t, a = f.render(f.props, f.state, f.context), n.n = A(null != a && a.type == O && null == a.key ? a.props.children : a), null != f.getChildContext && (r = M(M({}, r), f.getChildContext())), h || null == f.getSnapshotBeforeUpdate || (g = f.getSnapshotBeforeUpdate(v, d)), S(t, n, i, r, e, u, o, s, c), f.base = n.o; a = f.m.pop();)f.j && (f.state = f.j), a.call(f); h || null == v || null == f.componentDidUpdate || f.componentDidUpdate(v, d, g), b && (f.k = f.i = null) } else n.o = function (t, n, i, r, e, u, o, l) { var s, c, a, f, h = i.props, v = n.props; if (e = "svg" === n.type || e, null == t && null != u) for (s = 0; s < u.length; s++)if (null != (c = u[s]) && (null === n.type ? 3 === c.nodeType : c.localName === n.type)) { t = c, u[s] = null; break } if (null == t) { if (null === n.type) return document.createTextNode(v); t = e ? document.createElementNS("http://www.w3.org/2000/svg", n.type) : document.createElement(n.type), u = null } return null === n.type ? h !== v && (null != u && (u[u.indexOf(t)] = null), t.data = v) : n !== i && (null != u && (u = j.slice.call(t.childNodes)), a = (h = i.props || x).dangerouslySetInnerHTML, f = v.dangerouslySetInnerHTML, l || (f || a) && (f && a && f.O == a.O || (t.innerHTML = f && f.O || "")), function (t, n, i, r, e) { var u; for (u in i) u in n || R(t, u, null, i[u], r); for (u in n) e && "function" != typeof n[u] || "value" === u || "checked" === u || i[u] === n[u] || R(t, u, n[u], i[u], r) }(t, v, h, e, l), n.n = n.props.children, f || S(t, n, i, r, "foreignObject" !== n.type && e, u, o, x, l), l || ("value" in v && void 0 !== v.value && v.value !== t.value && (t.value = null == v.value ? "" : v.value), "checked" in v && void 0 !== v.checked && v.checked !== t.checked && (t.checked = v.checked))), t }(i.o, n, i, r, e, u, o, c); (a = m.diffed) && a(n) } catch (t) { m.o(t, n, i) } return n.o } function d(t, n) { for (var i; i = t.pop();)try { i.componentDidMount() } catch (t) { m.o(t, i.d) } m.c && m.c(n) } function E(t, n, i) { try { "function" == typeof t ? t(n) : t.current = n } catch (t) { m.o(t, i) } } function N(t, n, i) { var r, e, u; if (m.unmount && m.unmount(t), (r = t.ref) && E(r, null, n), i || "function" == typeof t.type || (i = null != (e = t.o)), t.o = t.l = null, null != (r = t.c)) { if (r.componentWillUnmount) try { r.componentWillUnmount() } catch (t) { m.o(t, n) } r.base = r.p = null } if (r = t.n) for (u = 0; u < r.length; u++)r[u] && N(r[u], n, i); null != e && y(e) } function z(t, n, i) { return this.constructor(t, i) } function g(t, n) { for (var i = 0; i < n.length; i++) { var r = n[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function b() { return (b = Object.assign || function (t) { for (var n = arguments, i = 1; i < arguments.length; i++) { var r = n[i]; for (var e in r) Object.prototype.hasOwnProperty.call(r, e) && (t[e] = r[e]) } return t }).apply(this, arguments) } m = {}, I.prototype.setState = function (t, n) { var i = this.j !== this.state && this.j || (this.j = M({}, this.state)); "function" == typeof t && !(t = t(i, this.props)) || M(i, t), null != t && this.d && (this.u = !1, n && this.m.push(n), e(this)) }, I.prototype.forceUpdate = function (t) { this.d && (t && this.m.push(t), this.u = !0, e(this)) }, I.prototype.render = O, s = [], n = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, i = m.debounceRendering, m.o = function (t, n, i) { for (var r; n = n.i;)if ((r = n.c) && !r.i) try { if (r.constructor && null != r.constructor.getDerivedStateFromError) r.setState(r.constructor.getDerivedStateFromError(t)); else { if (null == r.componentDidCatch) continue; r.componentDidCatch(t) } return e(r.k = r) } catch (n) { t = n } throw t }, o = x; var t = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)", l = "[\\s|\\(]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")\\s*\\)?", p = "[\\s|\\(]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")\\s*\\)?", _ = new RegExp("rgb" + l), H = new RegExp("rgba" + p), P = new RegExp("hsl" + l), $ = new RegExp("hsla" + p), T = "^(?:#?|0x?)", W = "([0-9a-fA-F]{1})", C = "([0-9a-fA-F]{2})", D = new RegExp(T + W + W + W + "$"), F = new RegExp(T + W + W + W + W + "$"), L = new RegExp(T + C + C + C + "$"), B = new RegExp(T + C + C + C + C + "$"), q = Math.log, G = Math.round, Z = Math.floor; function J(t, n, i) { return Math.min(Math.max(t, n), i) } function K(t, n) { var i = -1 < t.indexOf("%"), r = parseFloat(t); return i ? n / 100 * r : r } function Q(t) { return parseInt(t, 16) } function U(t) { return t.toString(16).padStart(2, "0") } var V = function () { function l(t, n) { this.$ = { h: 0, s: 0, v: 0, a: 1 }, t && this.set(t), this.onChange = n, this.initialValue = b({}, this.$) } var t = l.prototype; return t.set = function (t) { if ("string" == typeof t) /^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(t) ? this.hexString = t : /^rgba?/.test(t) ? this.rgbString = t : /^hsla?/.test(t) && (this.hslString = t); else { if ("object" != typeof t) throw new Error("Invalid color value"); t instanceof l ? this.hsva = t.hsva : "r" in t && "g" in t && "b" in t ? this.rgb = t : "h" in t && "s" in t && "v" in t ? this.hsv = t : "h" in t && "s" in t && "l" in t ? this.hsl = t : "kelvin" in t && (this.kelvin = t.kelvin) } }, t.setChannel = function (t, n, i) { var r; this[t] = b({}, this[t], ((r = {})[n] = i, r)) }, t.reset = function () { this.hsva = this.initialValue }, t.clone = function () { return new l(this) }, t.unbind = function () { this.onChange = void 0 }, l.hsvToRgb = function (t) { var n = t.h / 60, i = t.s / 100, r = t.v / 100, e = Z(n), u = n - e, o = r * (1 - i), l = r * (1 - u * i), s = r * (1 - (1 - u) * i), c = e % 6, a = [s, r, r, l, o, o][c], f = [o, o, s, r, r, l][c]; return { r: J(255 * [r, l, o, o, s, r][c], 0, 255), g: J(255 * a, 0, 255), b: J(255 * f, 0, 255) } }, l.rgbToHsv = function (t) { var n = t.r / 255, i = t.g / 255, r = t.b / 255, e = Math.max(n, i, r), u = Math.min(n, i, r), o = e - u, l = 0, s = e, c = 0 === e ? 0 : o / e; switch (e) { case u: l = 0; break; case n: l = (i - r) / o + (i < r ? 6 : 0); break; case i: l = (r - n) / o + 2; break; case r: l = (n - i) / o + 4 }return { h: 60 * l % 360, s: J(100 * c, 0, 100), v: J(100 * s, 0, 100) } }, l.hsvToHsl = function (t) { var n = t.s / 100, i = t.v / 100, r = (2 - n) * i, e = r <= 1 ? r : 2 - r, u = e < 1e-9 ? 0 : n * i / e; return { h: t.h, s: J(100 * u, 0, 100), l: J(50 * r, 0, 100) } }, l.hslToHsv = function (t) { var n = 2 * t.l, i = t.s * (n <= 100 ? n : 200 - n) / 100, r = n + i < 1e-9 ? 0 : 2 * i / (n + i); return { h: t.h, s: J(100 * r, 0, 100), v: J((n + i) / 2, 0, 100) } }, l.kelvinToRgb = function (t) { var n, i, r, e = t / 100; return r = e < 66 ? (n = 255, i = -155.25485562709179 - .44596950469579133 * (i = e - 2) + 104.49216199393888 * q(i), e < 20 ? 0 : .8274096064007395 * (r = e - 10) - 254.76935184120902 + 115.67994401066147 * q(r)) : (n = 351.97690566805693 + .114206453784165 * (n = e - 55) - 40.25366309332127 * q(n), i = 325.4494125711974 + .07943456536662342 * (i = e - 50) - 28.0852963507957 * q(i), 255), { r: J(Z(n), 0, 255), g: J(Z(i), 0, 255), b: J(Z(r), 0, 255) } }, l.rgbToKelvin = function (t) { for (var n, i = t.r, r = t.b, e = 2e3, u = 4e4; .4 < u - e;) { var o = l.kelvinToRgb(n = .5 * (u + e)); o.b / o.r >= r / i ? u = n : e = n } return n }, function (t, n, i) { n && g(t.prototype, n), i && g(t, i) }(l, [{ key: "hsv", get: function () { var t = this.$; return { h: t.h, s: t.s, v: t.v } }, set: function (t) { var n = this.$; if (t = b({}, n, t), this.onChange) { var i = { h: !1, v: !1, s: !1, a: !1 }; for (var r in n) i[r] = t[r] != n[r]; this.$ = t, (i.h || i.s || i.v || i.a) && this.onChange(this, i) } else this.$ = t } }, { key: "hsva", get: function () { return b({}, this.$) }, set: function (t) { this.hsv = t } }, { key: "hue", get: function () { return this.$.h }, set: function (t) { this.hsv = { h: t } } }, { key: "saturation", get: function () { return this.$.s }, set: function (t) { this.hsv = { s: t } } }, { key: "value", get: function () { return this.$.v }, set: function (t) { this.hsv = { v: t } } }, { key: "alpha", get: function () { return this.$.a }, set: function (t) { this.hsv = b({}, this.hsv, { a: t }) } }, { key: "kelvin", get: function () { return l.rgbToKelvin(this.rgb) }, set: function (t) { this.rgb = l.kelvinToRgb(t) } }, { key: "red", get: function () { return this.rgb.r }, set: function (t) { this.rgb = b({}, this.rgb, { r: t }) } }, { key: "green", get: function () { return this.rgb.g }, set: function (t) { this.rgb = b({}, this.rgb, { g: t }) } }, { key: "blue", get: function () { return this.rgb.b }, set: function (t) { this.rgb = b({}, this.rgb, { b: t }) } }, { key: "rgb", get: function () { var t = l.hsvToRgb(this.$), n = t.r, i = t.g, r = t.b; return { r: G(n), g: G(i), b: G(r) } }, set: function (t) { this.hsv = b({}, l.rgbToHsv(t), { a: void 0 === t.a ? 1 : t.a }) } }, { key: "rgba", get: function () { return b({}, this.rgb, { a: this.alpha }) }, set: function (t) { this.rgb = t } }, { key: "hsl", get: function () { var t = l.hsvToHsl(this.$), n = t.h, i = t.s, r = t.l; return { h: G(n), s: G(i), l: G(r) } }, set: function (t) { this.hsv = b({}, l.hslToHsv(t), { a: void 0 === t.a ? 1 : t.a }) } }, { key: "hsla", get: function () { return b({}, this.hsl, { a: this.alpha }) }, set: function (t) { this.hsl = t } }, { key: "rgbString", get: function () { var t = this.rgb; return "rgb(" + t.r + ", " + t.g + ", " + t.b + ")" }, set: function (t) { var n, i, r, e, u = 1; if ((n = _.exec(t)) ? (i = K(n[1], 255), r = K(n[2], 255), e = K(n[3], 255)) : (n = H.exec(t)) && (i = K(n[1], 255), r = K(n[2], 255), e = K(n[3], 255), u = K(n[4], 1)), !n) throw new Error("Invalid rgb string"); this.rgb = { r: i, g: r, b: e, a: u } } }, { key: "rgbaString", get: function () { var t = this.rgba; return "rgba(" + t.r + ", " + t.g + ", " + t.b + ", " + t.a + ")" }, set: function (t) { this.rgbString = t } }, { key: "hexString", get: function () { var t = this.rgb; return "#" + U(t.r) + U(t.g) + U(t.b) }, set: function (t) { var n, i, r, e, u = 255; if ((n = D.exec(t)) ? (i = 17 * Q(n[1]), r = 17 * Q(n[2]), e = 17 * Q(n[3])) : (n = F.exec(t)) ? (i = 17 * Q(n[1]), r = 17 * Q(n[2]), e = 17 * Q(n[3]), u = 17 * Q(n[4])) : (n = L.exec(t)) ? (i = Q(n[1]), r = Q(n[2]), e = Q(n[3])) : (n = B.exec(t)) && (i = Q(n[1]), r = Q(n[2]), e = Q(n[3]), u = Q(n[4])), !n) throw new Error("Invalid hex string"); this.rgb = { r: i, g: r, b: e, a: u / 255 } } }, { key: "hex8String", get: function () { var t = this.rgba; return "#" + U(t.r) + U(t.g) + U(t.b) + U(Z(255 * t.a)) }, set: function (t) { this.hexString = t } }, { key: "hslString", get: function () { var t = this.hsl; return "hsl(" + t.h + ", " + t.s + "%, " + t.l + "%)" }, set: function (t) { var n, i, r, e, u = 1; if ((n = P.exec(t)) ? (i = K(n[1], 360), r = K(n[2], 100), e = K(n[3], 100)) : (n = $.exec(t)) && (i = K(n[1], 360), r = K(n[2], 100), e = K(n[3], 100), u = K(n[4], 1)), !n) throw new Error("Invalid hsl string"); this.hsl = { h: i, s: r, l: e, a: u } } }, { key: "hslaString", get: function () { var t = this.hsla; return "hsla(" + t.h + ", " + t.s + "%, " + t.l + "%, " + t.a + ")" }, set: function (t) { this.hslString = t } }]), l }(); function X(t) { var n, i = t.width, r = t.sliderSize, e = t.borderWidth, u = t.handleRadius, o = t.padding, l = t.sliderShape, s = "horizontal" === t.layoutDirection; return r = null != (n = r) ? n : 2 * o + 2 * u, "circle" === l ? { handleStart: t.padding + t.handleRadius, handleRange: i - 2 * o - 2 * u, width: i, height: i, cx: i / 2, cy: i / 2, radius: i / 2 - e / 2 } : { handleStart: r / 2, handleRange: i - r, radius: r / 2, x: 0, y: 0, width: s ? r : i, height: s ? i : r } } function Y(t, n) { var i = X(t), r = i.width, e = i.height, u = i.handleRange, o = i.handleStart, l = "horizontal" === t.layoutDirection, s = l ? r / 2 : e / 2, c = o + function (t, n) { var i = n.hsva, r = n.rgb; switch (t.sliderType) { case "red": return r.r / 2.55; case "green": return r.g / 2.55; case "blue": return r.b / 2.55; case "alpha": return 100 * i.a; case "kelvin": var e = t.minTemperature, u = t.maxTemperature - e, o = (n.kelvin - e) / u * 100; return Math.max(0, Math.min(o, 100)); case "hue": return i.h /= 3.6; case "saturation": return i.s; case "value": default: return i.v } }(t, n) / 100 * u; return l && (c = -1 * c + u + 2 * o), { x: l ? s : c, y: l ? c : s } } var tt, nt = 2 * Math.PI, it = function (t, n) { return (t % n + n) % n }, rt = function (t, n) { return Math.sqrt(t * t + n * n) }; function et(t) { return t.width / 2 - t.padding - t.handleRadius - t.borderWidth } function ut(t) { var n = t.width / 2; return { width: t.width, radius: n - t.borderWidth, cx: n, cy: n } } function ot(t, n, i) { var r = t.wheelAngle, e = t.wheelDirection; return i && "clockwise" === e ? n = r + n : "clockwise" === e ? n = 360 - r + n : i && "anticlockwise" === e ? n = r + 180 - n : "anticlockwise" === e && (n = r - n), it(n, 360) } function lt(t, n, i) { var r = ut(t), e = r.cx, u = r.cy, o = et(t); n = e - n, i = u - i; var l = ot(t, Math.atan2(-i, -n) * (360 / nt)), s = Math.min(rt(n, i), o); return { h: Math.round(l), s: Math.round(100 / o * s) } } function st(t) { var n = t.width, i = t.boxHeight; return { width: n, height: null != i ? i : n, radius: t.padding + t.handleRadius } } function ct(t, n, i) { var r = st(t), e = r.width, u = r.height, o = r.radius, l = (n - o) / (e - 2 * o) * 100, s = (i - o) / (u - 2 * o) * 100; return { s: Math.max(0, Math.min(l, 100)), v: Math.max(0, Math.min(100 - s, 100)) } } function at(t, n, i, r) { for (var e = 0; e < r.length; e++) { var u = r[e].x - n, o = r[e].y - i; if (Math.sqrt(u * u + o * o) < t.handleRadius) return e } return null } function ft(t) { return { boxSizing: "border-box", border: t.borderWidth + "px solid " + t.borderColor } } function ht(t, n, i) { return t + "-gradient(" + n + ", " + i.map(function (t) { var n = t[0]; return t[1] + " " + n + "%" }).join(",") + ")" } function vt(t) { return "string" == typeof t ? t : t + "px" } var dt = ["mousemove", "touchmove", "mouseup", "touchend"], gt = function (n) { function t(t) { n.call(this, t), this.uid = (Math.random() + 1).toString(36).substring(5) } return n && (t.__proto__ = n), ((t.prototype = Object.create(n && n.prototype)).constructor = t).prototype.render = function (t) { var n = this.handleEvent.bind(this), i = { onMouseDown: n, ontouchstart: n }, r = "horizontal" === t.layoutDirection, e = null === t.margin ? t.sliderMargin : t.margin, u = { overflow: "visible", display: r ? "inline-block" : "block" }; return 0 < t.index && (u[r ? "marginLeft" : "marginTop"] = e), h(O, null, t.children(this.uid, i, u)) }, t.prototype.handleEvent = function (t) { var n = this, i = this.props.onInput, r = this.base.getBoundingClientRect(); t.preventDefault(); var e = t.touches ? t.changedTouches[0] : t, u = e.clientX - r.left, o = e.clientY - r.top; switch (t.type) { case "mousedown": case "touchstart": !1 !== i(u, o, 0) && dt.forEach(function (t) { document.addEventListener(t, n, { passive: !1 }) }); break; case "mousemove": case "touchmove": i(u, o, 1); break; case "mouseup": case "touchend": i(u, o, 2), dt.forEach(function (t) { document.removeEventListener(t, n, { passive: !1 }) }) } }, t }(I); function bt(t) { var n = t.r, i = t.url, r = n, e = n; return h("svg", { className: "IroHandle IroHandle--" + t.index + " " + (t.isActive ? "IroHandle--isActive" : ""), style: { "-webkit-tap-highlight-color": "rgba(0, 0, 0, 0);", transform: "translate(" + vt(t.x) + ", " + vt(t.y) + ")", willChange: "transform", top: vt(-n), left: vt(-n), width: vt(2 * n), height: vt(2 * n), position: "absolute", overflow: "visible" } }, i && h("use", Object.assign({ xlinkHref: function (t) { tt = tt || document.getElementsByTagName("base"); var n = window.navigator.userAgent, i = /^((?!chrome|android).)*safari/i.test(n), r = /iPhone|iPod|iPad/i.test(n), e = window.location; return (i || r) && 0 < tt.length ? e.protocol + "//" + e.host + e.pathname + e.search + t : t }(i) }, t.props)), !i && h("circle", { cx: r, cy: e, r: n, fill: "none", "stroke-width": 2, stroke: "#000" }), !i && h("circle", { cx: r, cy: e, r: n - 2, fill: t.fill, "stroke-width": 2, stroke: "#fff" })) } function pt(e) { var t = e.activeIndex, u = void 0 !== t && t < e.colors.length ? e.colors[t] : e.color, n = X(e), r = n.width, o = n.height, l = n.radius, s = Y(e, u), c = function (t, n) { var i = n.hsv, r = n.rgb; switch (t.sliderType) { case "red": return [[0, "rgb(0," + r.g + "," + r.b + ")"], [100, "rgb(255," + r.g + "," + r.b + ")"]]; case "green": return [[0, "rgb(" + r.r + ",0," + r.b + ")"], [100, "rgb(" + r.r + ",255," + r.b + ")"]]; case "blue": return [[0, "rgb(" + r.r + "," + r.g + ",0)"], [100, "rgb(" + r.r + "," + r.g + ",255)"]]; case "alpha": return [[0, "rgba(" + r.r + "," + r.g + "," + r.b + ",0)"], [100, "rgb(" + r.r + "," + r.g + "," + r.b + ")"]]; case "kelvin": for (var e = [], u = t.minTemperature, o = t.maxTemperature, l = o - u, s = u, c = 0; s < o; s += l / 8, c += 1) { var a = V.kelvinToRgb(s), f = a.r, h = a.g, v = a.b; e.push([12.5 * c, "rgb(" + f + "," + h + "," + v + ")"]) } return e; case "hue": return [[0, "#f00"], [16.666, "#ff0"], [33.333, "#0f0"], [50, "#0ff"], [66.666, "#00f"], [83.333, "#f0f"], [100, "#f00"]]; case "saturation": var d = V.hsvToHsl({ h: i.h, s: 0, v: i.v }), g = V.hsvToHsl({ h: i.h, s: 100, v: i.v }); return [[0, "hsl(" + d.h + "," + d.s + "%," + d.l + "%)"], [100, "hsl(" + g.h + "," + g.s + "%," + g.l + "%)"]]; case "value": default: var b = V.hsvToHsl({ h: i.h, s: i.s, v: 100 }); return [[0, "#000"], [100, "hsl(" + b.h + "," + b.s + "%," + b.l + "%)"]] } }(e, u); return h(gt, Object.assign({}, e, { onInput: function (t, n, i) { var r = function (t, n, i) { var r, e = X(t), u = e.handleRange, o = e.handleStart; r = "horizontal" === t.layoutDirection ? -1 * i + u + o : n - o, r = Math.max(Math.min(r, u), 0); var l = Math.round(100 / u * r); switch (t.sliderType) { case "kelvin": var s = t.minTemperature; return s + l / 100 * (t.maxTemperature - s); case "alpha": return l / 100; case "hue": return 3.6 * l; case "red": case "blue": case "green": return 2.55 * l; default: return l } }(e, t, n); e.parent.inputActive = !0, u[e.sliderType] = r, e.onInput(i, e.id) } }), function (t, n, i) { return h("div", Object.assign({}, n, { className: "IroSlider", style: Object.assign({}, { position: "relative", width: vt(r), height: vt(o), borderRadius: vt(l), background: "conic-gradient(#ccc 25%, #fff 0 50%, #ccc 0 75%, #fff 0)", backgroundSize: "8px 8px" }, i) }), h("div", { className: "IroSliderGradient", style: Object.assign({}, { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", borderRadius: vt(l), background: ht("linear", "horizontal" === e.layoutDirection ? "to top" : "to right", c) }, ft(e)) }), h(bt, { isActive: !0, index: u.index, r: e.handleRadius, url: e.handleSvg, props: e.handleProps, x: s.x, y: s.y })) }) } function yt(e) { var t = st(e), r = t.width, u = t.height, o = t.radius, l = e.colors, s = e.parent, n = e.activeIndex, c = void 0 !== n && n < e.colors.length ? e.colors[n] : e.color, a = function (t, n) { return [[[0, "#fff"], [100, "hsl(" + n.hue + ",100%,50%)"]], [[0, "rgba(0,0,0,0)"], [100, "#000"]]] }(0, c), f = l.map(function (t) { return function (t, n) { var i = st(t), r = i.width, e = i.height, u = i.radius, o = n.hsv, l = u, s = r - 2 * u, c = e - 2 * u; return { x: l + o.s / 100 * s, y: l + (c - o.v / 100 * c) } }(e, t) }); return h(gt, Object.assign({}, e, { onInput: function (t, n, i) { if (0 === i) { var r = at(e, t, n, f); null !== r ? s.setActiveColor(r) : (s.inputActive = !0, c.hsv = ct(e, t, n), e.onInput(i, e.id)) } else 1 === i && (s.inputActive = !0, c.hsv = ct(e, t, n)); e.onInput(i, e.id) } }), function (t, n, i) { return h("div", Object.assign({}, n, { className: "IroBox", style: Object.assign({}, { width: vt(r), height: vt(u), position: "relative" }, i) }), h("div", { className: "IroBox", style: Object.assign({}, { width: "100%", height: "100%", borderRadius: vt(o) }, ft(e), { background: ht("linear", "to bottom", a[1]) + "," + ht("linear", "to right", a[0]) }) }), l.filter(function (t) { return t !== c }).map(function (t) { return h(bt, { isActive: !1, index: t.index, fill: t.hslString, r: e.handleRadius, url: e.handleSvg, props: e.handleProps, x: f[t.index].x, y: f[t.index].y }) }), h(bt, { isActive: !0, index: c.index, fill: c.hslString, r: e.activeHandleRadius || e.handleRadius, url: e.handleSvg, props: e.handleProps, x: f[c.index].x, y: f[c.index].y })) }) } bt.defaultProps = { fill: "none", x: 0, y: 0, r: 8, url: null, props: { x: 0, y: 0 } }, pt.defaultProps = Object.assign({}, { sliderShape: "bar", sliderType: "value", minTemperature: 2200, maxTemperature: 11e3 }); function wt(e) { var r = ut(e).width, u = e.colors, o = (e.borderWidth, e.parent), l = e.color, s = l.hsv, c = u.map(function (t) { return function (t, n) { var i = n.hsv, r = ut(t), e = r.cx, u = r.cy, o = et(t), l = (180 + ot(t, i.h, !0)) * (nt / 360), s = i.s / 100 * o, c = "clockwise" === t.wheelDirection ? -1 : 1; return { x: e + s * Math.cos(l) * c, y: u + s * Math.sin(l) * c } }(e, t) }), a = { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", borderRadius: "50%", boxSizing: "border-box" }; return h(gt, Object.assign({}, e, { onInput: function (t, n, i) { if (0 === i) { if (!function (t, n, i) { var r = ut(t), e = r.cx, u = r.cy, o = t.width / 2; return rt(e - n, u - i) < o }(e, t, n)) return !1; var r = at(e, t, n, c); null !== r ? o.setActiveColor(r) : (o.inputActive = !0, l.hsv = lt(e, t, n), e.onInput(i, e.id)) } else 1 === i && (o.inputActive = !0, l.hsv = lt(e, t, n)); e.onInput(i, e.id) } }), function (t, n, i) { return h("div", Object.assign({}, n, { className: "IroWheel", style: Object.assign({}, { width: vt(r), height: vt(r), position: "relative" }, i) }), h("div", { className: "IroWheelHue", style: Object.assign({}, a, { transform: "rotateZ(" + (e.wheelAngle + 90) + "deg)", background: "clockwise" === e.wheelDirection ? "conic-gradient(red, yellow, lime, aqua, blue, magenta, red)" : "conic-gradient(red, magenta, blue, aqua, lime, yellow, red)" }) }), h("div", { className: "IroWheelSaturation", style: Object.assign({}, a, { background: "radial-gradient(circle closest-side, #fff, transparent)" }) }), e.wheelLightness && h("div", { className: "IroWheelLightness", style: Object.assign({}, a, { background: "#000", opacity: 1 - s.v / 100 }) }), h("div", { className: "IroWheelBorder", style: Object.assign({}, a, ft(e)) }), u.filter(function (t) { return t !== l }).map(function (t) { return h(bt, { isActive: !1, index: t.index, fill: t.hslString, r: e.handleRadius, url: e.handleSvg, props: e.handleProps, x: c[t.index].x, y: c[t.index].y }) }), h(bt, { isActive: !0, index: l.index, fill: l.hslString, r: e.activeHandleRadius || e.handleRadius, url: e.handleSvg, props: e.handleProps, x: c[l.index].x, y: c[l.index].y })) }) } var kt = function (i) { function t(t) { var n = this; i.call(this, t), this.colors = [], this.inputActive = !1, this.events = {}, this.activeEvents = {}, this.deferredEvents = {}, this.id = t.id, (0 < t.colors.length ? t.colors : [t.color]).forEach(function (t) { return n.addColor(t) }), this.setActiveColor(0), this.state = Object.assign({}, t, { color: this.color, colors: this.colors, layout: t.layout }) } return i && (t.__proto__ = i), ((t.prototype = Object.create(i && i.prototype)).constructor = t).prototype.addColor = function (t, n) { void 0 === n && (n = this.colors.length); var i = new V(t, this.onColorChange.bind(this)); this.colors.splice(n, 0, i), this.colors.forEach(function (t, n) { return t.index = n }), this.state && this.setState({ colors: this.colors }), this.deferredEmit("color:init", i) }, t.prototype.removeColor = function (t) { var n = this.colors.splice(t, 1)[0]; n.unbind(), this.colors.forEach(function (t, n) { return t.index = n }), this.state && this.setState({ colors: this.colors }), n.index === this.color.index && this.setActiveColor(0), this.emit("color:remove", n) }, t.prototype.setActiveColor = function (t) { this.color = this.colors[t], this.state && this.setState({ color: this.color }), this.emit("color:setActive", this.color) }, t.prototype.setColors = function (t, n) { var i = this; void 0 === n && (n = 0), this.colors.forEach(function (t) { return t.unbind() }), this.colors = [], t.forEach(function (t) { return i.addColor(t) }), this.setActiveColor(n), this.emit("color:setAll", this.colors) }, t.prototype.on = function (t, n) { var i = this, r = this.events; (Array.isArray(t) ? t : [t]).forEach(function (t) { (r[t] || (r[t] = [])).push(n), i.deferredEvents[t] && (i.deferredEvents[t].forEach(function (t) { n.apply(null, t) }), i.deferredEvents[t] = []) }) }, t.prototype.off = function (t, i) { var r = this; (Array.isArray(t) ? t : [t]).forEach(function (t) { var n = r.events[t]; n && n.splice(n.indexOf(i), 1) }) }, t.prototype.emit = function (t) { for (var n = this, i = [], r = arguments.length - 1; 0 < r--;)i[r] = arguments[r + 1]; var e = this.activeEvents; !!e.hasOwnProperty(t) && e[t] || (e[t] = !0, (this.events[t] || []).forEach(function (t) { return t.apply(n, i) }), e[t] = !1) }, t.prototype.deferredEmit = function (t) { for (var n, i = [], r = arguments.length - 1; 0 < r--;)i[r] = arguments[r + 1]; var e = this.deferredEvents; (n = this).emit.apply(n, [t].concat(i)), (e[t] || (e[t] = [])).push(i) }, t.prototype.setOptions = function (t) { this.setState(t) }, t.prototype.resize = function (t) { this.setOptions({ width: t }) }, t.prototype.reset = function () { this.colors.forEach(function (t) { return t.reset() }), this.setState({ colors: this.colors }) }, t.prototype.onMount = function (t) { this.el = t, this.deferredEmit("mount", this) }, t.prototype.onColorChange = function (t, n) { this.setState({ color: this.color }), this.inputActive && (this.inputActive = !1, this.emit("input:change", t, n)), this.emit("color:change", t, n) }, t.prototype.emitInputEvent = function (t, n) { 0 === t ? this.emit("input:start", this.color, n) : 1 === t ? this.emit("input:move", this.color, n) : 2 === t && this.emit("input:end", this.color, n) }, t.prototype.render = function (t, e) { var u = this, n = e.layout; return Array.isArray(n) || (n = [{ component: wt }, { component: pt }], e.transparency && n.push({ component: pt, options: { sliderType: "alpha" } })), h("div", { class: "IroColorPicker", id: e.id, style: { display: e.display } }, n.map(function (t, n) { var i = t.component, r = t.options; return h(i, Object.assign({}, e, r, { ref: void 0, onInput: u.emitInputEvent.bind(u), parent: u, index: n })) })) }, t }(I); kt.defaultProps = Object.assign({}, { width: 300, height: 300, color: "#fff", colors: [], padding: 6, layoutDirection: "vertical", borderColor: "#fff", borderWidth: 0, handleRadius: 8, activeHandleRadius: null, handleSvg: null, handleProps: { x: 0, y: 0 }, wheelLightness: !0, wheelAngle: 0, wheelDirection: "anticlockwise", sliderSize: null, sliderMargin: 12, boxHeight: null }, { colors: [], display: "block", id: null, layout: "default", margin: null }); var mt, xt, jt, Mt, Ot = (It.prototype = (mt = kt).prototype, Object.assign(It, mt), It.I = mt, It); function It(n, t) { var i, r = document.createElement("div"); function e() { var t = n instanceof Element ? n : document.querySelector(n); t.appendChild(i.base), i.onMount(t) } return function (t, n, i) { var r, e, u; m.i && m.i(t, n), e = (r = i === o) ? null : i && i.n || n.n, t = h(O, null, [t]), u = [], k(n, r ? n.n = t : (i || n).n = t, e || x, x, void 0 !== n.ownerSVGElement, i && !r ? [i] : e ? null : j.slice.call(n.childNodes), u, !1, i || x, r), d(u, t) }(h(mt, Object.assign({}, { ref: function (t) { return i = t } }, t)), r), "loading" !== document.readyState ? e() : document.addEventListener("DOMContentLoaded", e), i } return (jt = xt = xt || {}).version = "5.5.2", jt.Color = V, jt.ColorPicker = Ot, (Mt = jt.ui || (jt.ui = {})).h = h, Mt.ComponentBase = gt, Mt.Handle = bt, Mt.Slider = pt, Mt.Wheel = wt, Mt.Box = yt, xt });
    </script>

</body>

</html>